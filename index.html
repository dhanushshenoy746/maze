<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Maze Race ‚Äî You vs AI (Improved UI + Coin Effect)</title>
  <style>
    /* New Color Palette and improved UI styles */
    :root{
      --bg: #1c1c3a; /* Dark background */
      --wall: #4f5d75; /* Slate/Blue for walls */
      --path: #f0f0f0; /* Light path/canvas background */
      --player: #ffd166; /* Gold/Yellow for player */
      --ai: #ff6b6b; /* Coral/Red for AI */
      --goal: #60d394; /* Mint Green for goal */
      --coin: #f705ff; /* Yellow for coin */
      --text-main: #e0e0e0;
      --panel-bg: #2e3549; /* Darker panel background */
      --button-bg: #4a5568;
      --button-hover: #5c6b86;
    }

    * {
      user-select: none;
      }
    body{
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      background: var(--bg);
      color: var(--text-main);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    h1{
      font-size: 24px;
      margin: 20px 0 10px 0;
      color: var(--path);
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #game-wrap{
      display: flex;
      gap: 30px;
      align-items: flex-start;
      max-width: 1200px;
      padding: 20px;
    }
    canvas{
      background: var(--path);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.8), 0 0 0 4px var(--wall);
      transition: box-shadow 0.3s;
    }
    .panel{
      max-width: 320px;
      padding: 20px;
      background: var(--panel-bg);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .panel-group{
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    .panel button, .panel .btn{
      padding: 10px 15px;
      border-radius: 8px;
      border: none;
      background: var(--button-bg);
      color: var(--text-main);
      cursor: pointer;
      font-weight: bold;
      flex-grow: 1;
      transition: background 0.2s, transform 0.1s;
    }
    .panel button:hover{
      background: var(--button-hover);
    }
    .panel button:active{
      transform: scale(0.98);
    }
    .status{
      margin-top: 15px;
      background: #1a1a2e;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.8;
      border: 1px solid #3d4763;
    }
    .status div{
      display: flex;
      justify-content: space-between;
    }
    .status span{
      font-weight: bold;
      color: var(--player);
    }
    #aiState{
      color: var(--ai);
    }
    .controls{
      margin-top: 15px;
      font-size: 14px;
      padding: 8px 0;
      color: #b0b0b0;
      text-align: center;
      border-top: 1px solid #3d4763;
    }
    .legend{
      display: flex;
      gap: 15px;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #3d4763;
      flex-wrap: wrap;
    }
    .legend span{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    .swatch{
      width: 16px;
      height: 16px;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    footer{
      font-size: 12px;
      opacity: .7;
      margin-top: 20px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>‚ú® Maze Race ‚Äî You vs AI </h1>

  <div id="game-wrap">
    <canvas id="maze" width="720" height="720"></canvas>

    <div class="panel">
      <div class="panel-group">
        <button id="regen">üîÑ New Maze</button>
        <button id="reset">‚ñ∂Ô∏è Reset Positions</button>
      </div>

      <div class="status" id="status">
        <div>AI delay: <span id="aiDelay"></span>s</div>
        <div>Your moves: <span id="userMoves">0</span></div>
        <div>Coins Collected: <span id="coinsCollected">0</span></div>
        <div>AI state: <span id="aiState">waiting</span></div>
      </div>

      <div class="controls">Controls: **Arrow keys / WASD**</div>

      <div class="legend">
        <span><div class="swatch" style="background:var(--player)"></div>You</span>
        <span><div class="swatch" style="background:var(--ai)"></div>AI</span>
        <span><div class="swatch" style="background:var(--goal); border-radius:4px;"></div>Goal</span>
        <span><div class="swatch" style="background:var(--coin)"></div>Coin</span>
      </div>

      <footer>
        Goal: reach the green cell before the AI.<br>Collecting a coin decreases the AI's delay!
      </footer>
    </div>
  </div>

<script>
(() => {
  // ===== Config =====
  const cols = 24;
  const rows = 24;
  const canvas = document.getElementById('maze');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const cellW = w / cols, cellH = h / rows;

  // === UI elements ===
  const aiDelayEl = document.getElementById('aiDelay');
  const userMovesEl = document.getElementById('userMoves');
  const coinsCollectedEl = document.getElementById('coinsCollected'); // New element
  const aiStateEl = document.getElementById('aiState');
  const regenBtn = document.getElementById('regen');
  const resetBtn = document.getElementById('reset');

  // === Maze data ===
  let grid = [];
  let verticalWalls = [];
  let horizontalWalls = [];

  // === Players ===
  let player = {x:0,y:0};
  let ai = {x:0,y:1};
  const goal = {x:cols-1,y:rows-1};

  // === Coins ===
  let coins = [];
  const coinCount = 12;
  let collectedCoins = 0; // New coin counter

  // === AI timing ===
  let initialAIDelaySec = 60;
  let aiDelaySec = initialAIDelaySec;
  const minAIDelaySec = 0.15;
  const movePenaltySec = 1.0; // Penalty for *any* player move
  const coinBonusSec = 0.2; // Bonus for collecting a coin (new)
  let userMoves = 0;

  let aiTimer = null;
  let aiPath = [];

  function idx(x,y){return y*cols + x}

  // ===== Maze generator (No change to logic) =====
  function generateMaze(){
    grid = new Array(cols*rows).fill(0);
    verticalWalls = new Array(rows*(cols-1)).fill(true);
    horizontalWalls = new Array(cols*(rows-1)).fill(true);

    const stack = [];
    const startX = 0, startY = 0;
    grid[idx(startX,startY)] = 1;
    stack.push({x:startX,y:startY});

    while(stack.length){
      const cur = stack[stack.length-1];
      const {x,y} = cur;
      const neighbors = [];
      const dirs = [ [1,0],[-1,0],[0,1],[0,-1] ];
      for(const [dx,dy] of dirs){
        const nx = x+dx, ny = y+dy;
        if(nx>=0 && nx<cols && ny>=0 && ny<rows && grid[idx(nx,ny)]===0){
          neighbors.push({x:nx,y:ny,dx,dy});
        }
      }
      if(neighbors.length){
        const n = neighbors[Math.floor(Math.random()*neighbors.length)];
        if(n.dx===1){ verticalWalls[y*(cols-1) + x] = false; }
        else if(n.dx===-1){ verticalWalls[y*(cols-1) + n.x] = false; }
        else if(n.dy===1){ horizontalWalls[x*(rows-1) + y] = false; }
        else if(n.dy===-1){ horizontalWalls[x*(rows-1) + n.y] = false; }

        grid[idx(n.x,n.y)] = 1;
        stack.push({x:n.x,y:n.y});
      } else {
        stack.pop();
      }
    }

    // ===== Place coins (No change to logic) =====
    coins = [];
    for (let i = 0; i < coinCount; i++) {
      while (true) {
        const cx = Math.floor(Math.random()*cols);
        const cy = Math.floor(Math.random()*rows);

        if ((cx !== 0 || cy !== 0) &&
            (cx !== ai.x || cy !== ai.y) &&
            (cx !== goal.x || cy !== goal.y)) {
          coins.push({x:cx, y:cy});
          break;
        }
      }
    }
  }

  // ==== Walls (No change to logic) ====
  function hasWallBetween(x1,y1,x2,y2){
    if(x1===x2){
      const minY = Math.min(y1,y2);
      return horizontalWalls[x1*(rows-1)+minY];
    }
    if(y1===y2){
      const minX = Math.min(x1,x2);
      return verticalWalls[y1*(cols-1)+minX];
    }
    return true;
  }

  // ===== Draw (Minor cosmetic changes) =====
  function draw(){
    ctx.clearRect(0,0,w,h);

    // background (path)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--path');
    ctx.fillRect(0,0,w,h);

    // vertical walls
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall');
    ctx.lineWidth = 4; // Thicker walls for better contrast
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols-1;x++){
        if(verticalWalls[y*(cols-1)+x]){
          const sx = (x+1)*cellW;
          ctx.beginPath();
          ctx.moveTo(sx,y*cellH);
          ctx.lineTo(sx,(y+1)*cellH);
          ctx.stroke();
        }
      }
    }

    // horizontal walls
    for(let x=0;x<cols;x++){
      for(let y=0;y<rows-1;y++){
        if(horizontalWalls[x*(rows-1)+y]){
          const sy = (y+1)*cellH;
          ctx.beginPath();
          ctx.moveTo(x*cellW,sy);
          ctx.lineTo((x+1)*cellW,sy);
          ctx.stroke();
        }
      }
    }

    // goal (square)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--goal');
    ctx.fillRect(goal.x*cellW+4, goal.y*cellH+4, cellW-8, cellH-8);

    // ===== coins (draw before players) =====
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--coin');
    coins.forEach(c => {
      ctx.beginPath();
      // Draw a small circle
      ctx.arc(
        c.x*cellW + cellW/2,
        c.y*cellH + cellH/2,
        Math.min(cellW,cellH)*0.22, // Slightly larger coin
        0, Math.PI*2
      );
      ctx.fill();
    });

    // player (circle)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player');
    ctx.beginPath();
    ctx.arc(player.x*cellW + cellW/2, player.y*cellH + cellH/2, Math.min(cellW,cellH)*0.35, 0, Math.PI*2); // Larger player
    ctx.fill();

    // AI (circle)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ai');
    ctx.beginPath();
    ctx.arc(ai.x*cellW + cellW/2, ai.y*cellH + cellH/2, Math.min(cellW,cellH)*0.35, 0, Math.PI*2); // Larger AI
    ctx.fill();
  }

  // ===== A* and MinHeap (No change to logic) =====
  function neighbors(x,y){
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    const out = [];
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(nx>=0 && nx<cols && ny>=0 && ny<rows && !hasWallBetween(x,y,nx,ny)){
        out.push({x:nx,y:ny});
      }
    }
    return out;
  }

  function heuristic(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)}

  function findPath(start,goalPos){
    const open = new MinHeap((a,b)=>a.f-b.f);
    const startNode = {x:start.x,y:start.y,g:0,f:heuristic(start,goalPos),came:null,key:start.x+","+start.y};
    const map = new Map();
    map.set(startNode.key,startNode);
    open.push(startNode);
    const closed = new Set();

    while(!open.empty()){
      const cur = open.pop();
      if(cur.x===goalPos.x && cur.y===goalPos.y){
        const p=[]; let n=cur;
        while(n){p.unshift({x:n.x,y:n.y});n=n.came;}
        return p;
      }
      closed.add(cur.key);
      for(const nb of neighbors(cur.x,cur.y)){
        const key = nb.x+","+nb.y;
        if(closed.has(key)) continue;
        const g = cur.g+1;
        let node = map.get(key);
        if(!node || g < node.g){
          const newN = {x:nb.x,y:nb.y,g,f:g+heuristic(nb,goalPos),came:cur,key};
          map.set(key,newN);
          open.push(newN);
        }
      }
    }
    return [];
  }

  class MinHeap{
    constructor(cmp){this.data=[];this.cmp=cmp}
    empty(){return this.data.length===0}
    push(v){this.data.push(v);this._up(this.data.length-1)}
    pop(){
      if(this.data.length===0) return null;
      const ret = this.data[0];
      const last = this.data.pop();
      if(this.data.length){this.data[0] = last; this._down(0);}
      return ret;
    }
    _up(i){
      while(i>0){
        const p=(i-1)>>1;
        if(this.cmp(this.data[i],this.data[p])<0){
          [this.data[i],this.data[p]]=[this.data[p],this.data[i]];
          i=p;
        } else break;
      }
    }
    _down(i){
      const n=this.data.length;
      while(true){
        let l=i*2+1;
        if(l>=n) break;
        let r=l+1;
        let s=l;
        if(r<n && this.cmp(this.data[r],this.data[l])<0) s=r;
        if(this.cmp(this.data[s],this.data[i])<0){
          [this.data[s],this.data[i]]=[this.data[i],this.data[s]];
          i=s;
        } else break;
      }
    }
  }

  // ==== AI movement (No change to logic, just text update) ====
  function scheduleAIMove(){
    if(aiTimer){clearTimeout(aiTimer); aiTimer=null;}

    if(ai.x===goal.x && ai.y===goal.y){
      aiStateEl.textContent = "AI reached goal ‚Äî AI wins!";
      return;
    }
    if(player.x===goal.x && player.y===goal.y){
      aiStateEl.textContent = "Player reached goal ‚Äî You win!";
      return;
    }

    const delayMs = Math.max(minAIDelaySec*1000, aiDelaySec*1000);
    aiStateEl.textContent = `next move in ${ (delayMs/1000).toFixed(2) }s`;

    aiTimer = setTimeout(()=>{
      aiStateEl.textContent = "thinking";

      // AI calculates the path
      aiPath = findPath({x:ai.x,y:ai.y},goal);
      if(!aiPath || aiPath.length===0){
        aiStateEl.textContent = "stuck";
        // If stuck, try again after a small delay
        aiTimer = setTimeout(scheduleAIMove, minAIDelaySec*1000);
        return;
      }

      if(aiPath.length>1){
        const next = aiPath[1];
        ai.x = next.x; ai.y = next.y;
        draw();

        if(ai.x===goal.x && ai.y===goal.y){
          aiStateEl.textContent="AI reached goal ‚Äî AI wins!";
          return;
        }

        scheduleAIMove();
      }
    }, delayMs);
  }

  // ===== Player move (UPDATED coin collection logic) =====
  function tryMovePlayer(dx,dy){
    const nx = player.x+dx, ny = player.y+dy;
    if(nx<0 || nx>=cols || ny<0 || ny>=rows) return;
    if(hasWallBetween(player.x,player.y,nx,ny)) return;

    player.x=nx; player.y=ny;
    userMoves++;
    userMovesEl.textContent = userMoves;

    // Standard player move penalty (slows AI)
    aiDelaySec = Math.max(minAIDelaySec, aiDelaySec - movePenaltySec);

    // ===== coin collection (UPDATED logic) =====
    let coinCollectedThisTurn = false;
    for(let i=coins.length-1;i>=0;i--){
      if(coins[i].x===player.x && coins[i].y===player.y){
        coins.splice(i,1);
        collectedCoins++;
        coinCollectedThisTurn = true;
        
        // **NEW LOGIC: Decrease AI delay by coinBonusSec (0.1s)**
        aiDelaySec = Math.max(minAIDelaySec, aiDelaySec + coinBonusSec);
        
        coinsCollectedEl.textContent = collectedCoins;
        break; // Only one coin per cell
      }
    }

    aiDelayEl.textContent = aiDelaySec.toFixed(2);

    draw();

    if(player.x===goal.x && player.y===goal.y){
      aiStateEl.textContent="Player reached goal ‚Äî You win! üéâ";
      if(aiTimer) clearTimeout(aiTimer);
      return;
    }

    // After a move, clear the old timer and schedule the next AI move
    if(aiTimer) clearTimeout(aiTimer);
    scheduleAIMove();
  }

  // === Keyboard (No change to logic) ===
  window.addEventListener('keydown', (e)=>{
    const k=e.key;
    if(["ArrowUp","w","W"].includes(k)) tryMovePlayer(0,-1);
    else if(["ArrowDown","s","S"].includes(k)) tryMovePlayer(0,1);
    else if(["ArrowLeft","a","A"].includes(k)) tryMovePlayer(-1,0);
    else if(["ArrowRight","d","D"].includes(k)) tryMovePlayer(1,0);
  });

  // ==== Reset (UPDATED to include coin reset) ====
  function resetPositions(){
    player={x:0,y:0};
    ai={x:0,y:1};
    userMoves=0;
    collectedCoins=0; // Reset collected coins
    aiDelaySec=initialAIDelaySec;
    
    // Update UI elements
    aiDelayEl.textContent=aiDelaySec.toFixed(2);
    userMovesEl.textContent=userMoves;
    coinsCollectedEl.textContent=collectedCoins;
    aiStateEl.textContent="waiting";
    
    if(aiTimer) clearTimeout(aiTimer);

    scheduleAIMove();
    draw();
  }

  regenBtn.addEventListener('click',()=>{
    if(aiTimer) clearTimeout(aiTimer);
    generateMaze();
    resetPositions();
  });
  resetBtn.addEventListener('click',resetPositions);

  generateMaze();
  resetPositions();
  draw();

})();
</script>
</body>
</html>